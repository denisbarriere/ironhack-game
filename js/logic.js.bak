/* Javascript file handling the game logic */

/*
 * PLAYER
 */
function Player() {
  this.activeTiles = []; // list of all the tiles the player created
  this.currentTile; // Last tile created by the player
  this.nextTile; // Next tile the player want to create
  this.direction; // Direction requested by the user on keypress / swipe
  this.levelScore = 0; // Number of points made by the player in the current level
  this.score = 0; // Overall player score across levels
  this.nbLevelMoves = 0; // Number of tiles moved by the player in the level
  this.nbMoves = 0; // Overall number of tiles moved by the player
}

/*
 * PLAYER FUNCTIONS
 */
Player.prototype.move = function (level) {
  // Tells if a user can move or not
  var isStuck = false;

  switch(this.direction) {
    case 'left':
      // Get the next position and color
      this.nextTile = { row: this.currentTile.row, column: this.currentTile.column - 1, color: level.nextColorsQueue[0], current: false };
      break;

    case 'right':
      // Get the next position and color
      this.nextTile = { row: this.currentTile.row, column: this.currentTile.column + 1, color: level.nextColorsQueue[0], current: false };
      break;

    case 'up':
      // Get the next position and color
      this.nextTile = { row: this.currentTile.row - 1,column: this.currentTile.column, color: level.nextColorsQueue[0], current: false };
      break;

    case 'down':
      // Get the next position and color
      this.nextTile = { row: this.currentTile.row + 1,column: this.currentTile.column, color: level.nextColorsQueue[0], current: false };
      break;
    default: 
      console.log("[log] Player.prototype.move: '" + this.direction + "' direction is not defined");
  }

  // If the next tile is not active and not out of the board
  if ( this.isNextTileFree(this.nextTile) && this.isNextTileInBoard(this.nextTile, level) ) {

    // Inscrease move counters
    this.nbLevelMoves += 1;
    this.nbMoves += 1;

    
    // If the user cannot move anymore, then move the tile and end game
    if ( !this.isFreeTileAround(this.nextTile, level) ) {
      isStuck = true;
    }

    // The move is correct
    // Save the move
    var currenrValidMove = {
      row: this.nextTile.row,
      column: this.nextTile.column,
      color: this.nextTile.color,
      current: true
    };

    // Set the new current tile
    this.currentTile = currenrValidMove;

    // Remove current from previous tile
    this.activeTiles[this.activeTiles.length - 1].current = false;

    // Add this new tile to the activeTiles array
    this.activeTiles.push(currenrValidMove);
    
    // Update the next colors array
    level.nextColorsQueue.shift();
    if ( level.nextColorsQueue.length < 3 ) {
      // If not enough colors are remaining, then push the inital set of colors back 
      var levelParams = eval("level"+level.number+"Params");
      for (var index = 0; index < levelParams.nextColorsQueue.length; index += 1) {
        level.nextColorsQueue.push(levelParams.nextColorsQueue[index]);
      }
    }

    // End game if stuck
    if ( isStuck ) {
      // No free tiles around => Game Over
      console.log("booo");
      level.lost(this);
    } 

    // If the next position makes 3 tiles of the same color
    if ( this.isMatch(level) ) {
      console.log("FUCKING MATCH!!!!");
    } 
  } else if ( this.isFreeTileAround(this.currentTile, level) ) {
    console.log("Next position is either not free or out of bound");
  } else {
    // No free tiles around => Game Over
    console.log("Do we ever get here?")
    level.lost(this);

  }
}


// Function used to check if the next tile is free to move
Player.prototype.isNextTileFree = function (nextPos) {
  // Look in the active tiles to see if the next position is matching and return the opposite (if match, the tile is NOT free)
  return !this.activeTiles.some(function (element) { 
    return element.row == nextPos.row && element.column == nextPos.column;
  }.bind(this));
};


// Function used to check if the next tile is out of the board
Player.prototype.isNextTileInBoard = function (nextPos, level) {
  if (  nextPos.row < 0 || 
        nextPos.row > level.height - 1 ||
        nextPos.column < 0 ||
        nextPos.column > level.width - 1
  ) { 
    return false;
  } else { 
    return true;
  }
};


// Check if there is any free cell around the current position
Player.prototype.isFreeTileAround = function (pos, level) {
  
  // Set the values of the cells around
  var upTile    = { row: pos.row - 1, column: pos.column     };
  var rightTile = { row: pos.row    , column: pos.column + 1 };
  var downTile  = { row: pos.row + 1, column: pos.column     };
  var leftTile  = { row: pos.row    , column: pos.column - 1 };

  if (  (this.isNextTileFree(upTile) && this.isNextTileInBoard(upTile, level)) ||
        (this.isNextTileFree(rightTile) && this.isNextTileInBoard(rightTile, level)) ||
        (this.isNextTileFree(downTile) && this.isNextTileInBoard(downTile, level)) ||
        (this.isNextTileFree(leftTile) && this.isNextTileInBoard(leftTile, level))
  ) { 
    return true;
  }
  
  console.log("You are stuck mate :'(");
  // If we are here, it means that there is no free cell around
  return false;
}

// Tells if a tile is active
Player.prototype.isActive = function(tile) {
  // Returns true if tile is found in the active array
  return this.activeTiles.some(function (element) { 
    return element.row == tile.row && element.column == tile.column;
  }.bind(this));
};


// Tells if a tile is active
Player.prototype.isSameColor = function(tile1, tile2) {
  // Retrieve the data of the first tile to test, from the active tiles array
  var tile1FromActiveTiles = this.activeTiles.find(function(element) {
    return element.row === tile1.row && element.column === tile1.column;
  }) || 0; // Set to 0 if undefined

  // Retrieve the data of second tile to test, from the active tiles array
  var tile2FromActiveTiles = this.activeTiles.find(function(element) {
    return element.row === tile2.row && element.column === tile2.column;
  }) || 0; // Set to 0 if undefined
  
  console.log("Tile 1: " + tile1FromActiveTiles.row +", "+tile1FromActiveTiles.column + " - Tile 2: " + tile2FromActiveTiles.row + ", " + tile2FromActiveTiles.column);
  console.log(tile1FromActiveTiles.color + " - " + tile2FromActiveTiles.color);


  // if the color matches, return true
  return tile1FromActiveTiles.color === tile2FromActiveTiles.color;
};

/* FUNCTION: Checks if a tile is touching another one with the same color, either up, right, down or left
 * PARAMETERS: Object including the reference tile
 * RETURNS: [Array] of objects. Each object if defined as following:
 * { tile1: <first tile compared>,
 *   tile2: <second tile compared>,
 *   touch: <true: if the two tiles are touching and of the same color, else false>
 * }
 */
Player.prototype.touchWithColor = function(tileToCheck) {
  // Variables used to check if tiles are touching is a direction
  var touchUp = false;
  var touchRight = false;
  var touchDown = false;
  var touchLeft = false;

  // Variables used to check if touching tiles have the same color
  var upColorMatch = false;
  var rightColorMatch = false;
  var downColorMatch = false;
  var leftColorMatch = false;

  // Set the values of the cells around
  var upTile    = { row: tileToCheck.row - 1, column: tileToCheck.column     };
  var rightTile = { row: tileToCheck.row    , column: tileToCheck.column + 1 };
  var downTile  = { row: tileToCheck.row + 1, column: tileToCheck.column     };
  var leftTile  = { row: tileToCheck.row    , column: tileToCheck.column - 1 };
  
  // Checks if two tiles are touching and have the same color 
  // UP
  if ( this.isActive(upTile) ) {
    touchUp = true;
    if ( this.isSameColor(tileToCheck, upTile) ) {
      upColorMatch = true;
     }
  }

  // RIGHT
  if ( this.isActive(rightTile) ) {
    touchRight = true;
    if ( this.isSameColor(tileToCheck, rightTile) ) {
      rightColorMatch = true;
     }
  }

  // DOWN
  if ( this.isActive(downTile) ) {
    touchDown = true;
    if ( this.isSameColor(tileToCheck, downTile) ) {
      downColorMatch = true;
     }
  }

  // RIGHT
  if ( this.isActive(leftTile) ) {
    touchLeft = true;
    if ( this.isSameColor(tileToCheck, leftTile) ) {
      leftColorMatch = true;
     }
  }

  // Built the array to return
  // This array inclues objects storing the test results clockwise (0: result of test up, 1: result of test right, 2: result of test down, 3: result of test left)
  var objToReturn = [
    { tile1: tileToCheck, tile2: upTile, touchDirection: touchUp, colorMatch: upColorMatch },
    { tile1: tileToCheck, tile2: rightTile, touchDirection: touchRight, colorMatch: rightColorMatch },
    { tile1: tileToCheck, tile2: downTile, touchDirection: touchDown, colorMatch: downColorMatch },
    { tile1: tileToCheck, tile2: leftTile, touchDirection: touchLeft, colorMatch: leftColorMatch }        
  ];

  // Return the array
  return objToReturn;
};

/*
 * Check if 3 or more tiles of the same color are touching
*/
Player.prototype.isMatch = function(level) {
  
  // [ARRAY] used to store the matches, initialised with the current tile
  var matches = [this.activeTiles[this.activeTiles.length - 1]];
  
  // [ARRAY] used to store the list of active tiles used for match finding
  var activeTilesLeftToCheck = this.activeTiles;
  
  // [ARRAY] used to store the return of the 'Player.touchWithColor' function
  var isTouchingWithSameColor = [];

  // [INTEGER] used as index of the 'activeTilesLeftToCheck' array in the following loop going backwards
  var tileIndex = activeTilesLeftToCheck.length - 1;

  // Check for matches until there is no tile to compare
  do {

    // Test for touching tiles with the same color
    isTouchingWithSameColor = this.touchWithColor(activeTilesLeftToCheck[tileIndex]);

    // Check if matches have been found by the 'Player.touchWithColor' function. 
    // The function returns an array of object where:
    // Row 0: result of check up
    // Row 1: result of check right
    // Row 2: result of check down
    // Row 3: result of check left
    
    // TOUCH UP
    if ( isTouchingWithSameColor[0].touchDirection ) { 
      console.log("Touch Up");
      if ( isTouchingWithSameColor[0].colorMatch ) { 
        console.log("color match: ", activeTilesLeftToCheck[tileIndex].color);
  
        // Store the matching results
        matches.push(isTouchingWithSameColor[0].tile2);

        // Continue looking for matches in this direction
      } else {
        
        // Remove the touching tiles with a different color form the 'activeTilesLeftToCheck' array to avoid checking them later
        activeTilesLeftToCheck.splice(1, activeTilesLeftToCheck.indexOf(isTouchingWithSameColor[0].tile2));
      }
    }
      

    // TOUCH RIGHT
    if ( isTouchingWithSameColor[1].touchDirection ) { 
      console.log("Touch Right");
      // Store the matching results
      matches.push(isTouchingWithSameColor[1].tile2);
    }


    // TOUCH DOWN
    if ( isTouchingWithSameColor[2].touchDirection ) { 
      console.log("Touch Down");
      // Store the matching results
      matches.push(isTouchingWithSameColor[2].tile2);
      // Remove the match from the 'activeTilesLeftToCheck' array
      activeTilesLeftToCheck.splice(1, tileIndex);
      
      // Set the next index to check to the matching tile
      tileIndex = activeTilesLeftToCheck.indexOf(isTouchingWithSameColor[2].tile1);
    }


    // TOUCH LEFT
    if ( isTouchingWithSameColor[3].touchDirection ) { 
      console.log("Touch Left");
      // Store the matching results
      matches.push(isTouchingWithSameColor[3].tile2);
    }

  } while (activeTilesLeftToCheck.length > 0);

    // If matches has at least 3 items, then we have a match
    if ( matches.length > 2 ) {
      return true;
    }

  return false;
}  


/*
 * LEVEL
 */
function Level(level) {
  this.number = level.number;
  this.width = level.width;
  this.height = level.height;
  this.initState = level.initState;
  this.board = [];
  this.nextColorsQueue = [];
  this.success = level.success;

  // Initialise the nextColorsQueue
  for (var index = 0; index < level.nextColorsQueue.length; index += 1) {
    this.nextColorsQueue.push(level.nextColorsQueue[index]);
  }
}

/*
 * LEVEL FUNCTIONS
 */
// Function used to initialise the level
Level.prototype.initBoard = function(player) { 
  var currentIteration;

  /* Create the board */
  for (var row = 0; row < this.height; row +=1 ) {
    for (var column = 0; column < this.width; column +=1 ) {
      $('.board').append($('<div>')
        .addClass('cell')
        .attr('data-row', row)
        .attr('data-col', column)
      );

      // Build the board object
      this.board.push([row, column]);
    }
  }

  // For each tile in the initialState array:
  // Push it to the activeTiles array, in order to draw
  // Set the currentTile
  for (var index = 0 ; index < this.initState.length; index += 1) {
    currentIteration = {
        row: this.initState[index].row,
        column: this.initState[index].column,
        color: this.initState[index].color,
        current: false
    };
    // If the current item is the current one, set it in the activeTiles array
    if ( this.initState[index].current ) {
      currentIteration.current = true;
      player.currentTile = currentIteration;
    }

    // Push the item to the activeTiles array
    player.activeTiles.push(currentIteration);
  } 

  // Draw the player information (active / current tiles, score and next queue)
  this.drawPlayer(player);

  // Assign keyboard key events to the game
  this.assignControlsToKeys(player);
}


// Bind arrow keys with move actions
Level.prototype.assignControlsToKeys = function(player) {
  $('body').on('keydown', function(e) {
    if( e.keyCode === 38 ||
        e.keyCode === 40 ||
        e.keyCode === 37 ||
        e.keyCode === 39 ||
        e.keyCode === 80
    ) {
      switch (e.keyCode) {
        case 38: // arrow up
          player.direction = 'up';
          break;
        case 40: // arrow down
          player.direction = 'down';
          break;
        case 37: // arrow left
          player.direction = 'left';
          break;
        case 39: // arrow right
          player.direction = 'right';
          break;
        case 80: // p pause
          break;
      }
      this.update(player);
    }
  }.bind(this));
};


// Function used to clear the board
Level.prototype.clearLevel = function() {
  // Reset the Level Object
  this.board = [];
  this.nextColorsQueue = [];

  // Reset the colorQueue to its initial value
  var levelParams = eval("level"+this.number+"Params");
  for (var index = 0; index < levelParams.nextColorsQueue.length; index += 1) {
    this.nextColorsQueue.push(levelParams.nextColorsQueue[index]);
  }
  
  // Clear the board on the screen
  $('.board > .cell').remove();
}


// Clear the player from the board
Level.prototype.clearPlayer = function(player, clearAllPlayerData) {
  if (clearAllPlayerData) {
    // Reset the player object (related to the level)
    player.activeTiles = [];
    player.currentTile = {};
    player.nextTile = {};
    player.direction = 'None';
    player.levelScore = 0;
    player.nbLevelMoves = 0;

    // Clear lost div
    $('.lost').remove();
  }

  // Clear each active tile on the board (based on color)
  availableColor.forEach(function(color) {
    $('.board > .' + color).removeClass(color);
  });

  // Clear current div
  $('.current').remove();

  // Clear the next colors
  $('.color-list li').removeAttr('class');
  $('.color-list li').addClass('preview-cell');
};


// Draw player
Level.prototype.drawPlayer = function(player) {

  // Draw each active tile
  for (var index = 0 ; index < player.activeTiles.length; index += 1) {
    // Find the cell to update on the board
    var selector = '[data-row=' + player.activeTiles[index].row + ']' +
                   '[data-col=' + player.activeTiles[index].column + ']';
    // Init the color on the board
    $(selector).addClass(player.activeTiles[index].color);
    
    // Set the current cell ( the cell with the o icon which is the first one the user can use )
    if ( player.activeTiles[index].current ) {
      $(selector).append($('<div>').addClass('current'));
    }
  }

  // Set the player current score
  $('.level-goal__progress').text(player.levelScore);
   // Set the target scope for the level
  $('.level-goal__target').text(this.success);

  // Init the first next three colors from the color-list
  this.updateColorList();

};


// Update display
Level.prototype.update = function(player) {
  player.move(this);
  this.clearPlayer(player);
  this.drawPlayer(player);
}


// Function used to update the next 3 colors available on the level screen
Level.prototype.updateColorList = function() {
  // Loop over the first three elements on the array and display them
  for (var index = 0; index < 3; index += 1) {
      $('.color-list li:nth-child(' + (index + 1) + ')').addClass(this.nextColorsQueue[index]);
  }
};


// Function that resets the level
Level.prototype.resetLevel = function(player) {
  this.clearPlayer(player, true);
  this.clearLevel();
  // Remove the key event lister
  $('body').off("keydown");
  
  this.initBoard(player);
}


// Function that ends the level
Level.prototype.endLevel = function(player) {
  timeoutId = setTimeout(function() { 
    alert("OK, see you around.")
  }, 200);

  // Remove the key event lister
  $('body').off("keydown");
}


// Function handling when a user lost the level
Level.prototype.lost = function(player) {
  // A little delay is required to delete the current icon
  setTimeout(function() { $('.current').remove(); }, 10 );
 
  // Change the current icon to the lost on
  var selector = '[data-row=' + player.currentTile.row + ']' +
                 '[data-col=' + player.currentTile.column + ']';

  // Draw the lost icon on the current cell
  $(selector).append($('<div>').addClass('lost'));
  $('.lost').html("&#9587;");
  
  // Ask the user what they want to do after a few seconds
  var timeoutId = setTimeout(function() {
    var userChoice = confirm("Too bad, you just lost! Wanna retry?");
    // If the user wants to retry, reset everything
    if ( userChoice ) {
      console.log("Cool, let's roll!");
      this.resetLevel(player);

    } else {
      this.endLevel();
    }
  }.bind(this), 400);
}

/* 
 * GAME
 */
// Constructor
function Game() {
  
  var gameObject = this;

  // Initialise the Player
  this.player = new Player();

  // Initialise Level 1 Board
  this.level = new Level(level1Params);
  this.level.initBoard(this.player);

}

/*
 * GAME FUNCTIONS
 */
